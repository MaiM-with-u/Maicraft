import os
import ast
import re
import json
import logging
from typing import Optional
from agent.prompt_manager.prompt_manager import prompt_manager, PromptTemplate
from config import global_config
from openai_client.llm_request import LLMClient
from openai_client.modelconfig import ModelConfig

class ActionLearner:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        model_config = ModelConfig(
            model_name=global_config.llm.model,
            api_key=global_config.llm.api_key,
            base_url=global_config.llm.base_url,
            max_tokens=global_config.llm.max_tokens,
            temperature=global_config.llm.temperature
        )
        self.llm_client = LLMClient(model_config)
    
    async def save_learnt_action_code(self, code: str) -> str:
        """
        将成功执行的代码保存到 agent/learnt_actions 目录
        文件名包含时间与任务目标，便于检索
        """
        # 准备目录
        save_dir = os.path.join(os.path.dirname(__file__), "learnt_actions")
        os.makedirs(save_dir, exist_ok=True)

        # 从代码中提取函数名作为文件名
        function_name = None
        try:
            parsed_ast = ast.parse(code)
            for node in parsed_ast.body:
                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    function_name = node.name
                    break
        except Exception:
            function_name = None

        # 回退：若无法解析函数名
        if not function_name:
            return
        else:
            # Python 函数名已是合法标识符，可直接用作文件名
            base_name = function_name

        filename = f"{base_name}.py"
        filepath = os.path.join(save_dir, filename)

        # 若重名则依次追加 V2/V3/V4...，并同步修改函数名
        chosen_version_index = 1
        if os.path.exists(filepath):
            version_index = 2
            while True:
                candidate = f"{base_name}V{version_index}.py"
                candidate_path = os.path.join(save_dir, candidate)
                if not os.path.exists(candidate_path):
                    filename = candidate
                    filepath = candidate_path
                    chosen_version_index = version_index
                    break
                version_index += 1

        # 如需避免函数重名，则把代码中的首个函数名也加相同后缀
        if function_name and chosen_version_index > 1:
            new_function_name = f"{function_name}V{chosen_version_index}"

            def _rename_function_in_code(src_code: str, old_name: str, new_name: str) -> str:
                try:
                    tree = ast.parse(src_code)

                    class NameRenamer(ast.NodeTransformer):
                        def visit_FunctionDef(self, node):
                            if node.name == old_name:
                                node.name = new_name
                            self.generic_visit(node)
                            return node

                        def visit_AsyncFunctionDef(self, node):
                            if node.name == old_name:
                                node.name = new_name
                            self.generic_visit(node)
                            return node

                        def visit_Call(self, node):
                            self.generic_visit(node)
                            if isinstance(node.func, ast.Name) and node.func.id == old_name:
                                node.func.id = new_name
                            return node

                    new_tree = NameRenamer().visit(tree)
                    ast.fix_missing_locations(new_tree)
                    # ast.unparse 需 Python 3.9+
                    new_code_str = ast.unparse(new_tree)
                    return new_code_str
                except Exception:
                    # 回退到正则替换：
                    # 1) def old_name(
                    pattern_def = rf"(?m)^(\s*def\s+){re.escape(old_name)}(\s*\()"
                    src_code = re.sub(pattern_def, rf"\\1{new_name}\\2", src_code)
                    # 2) async def old_name(
                    pattern_async_def = rf"(?m)^(\s*async\s+def\s+){re.escape(old_name)}(\s*\())"
                    src_code = re.sub(pattern_async_def, rf"\\1{new_name}\\2", src_code)
                    # 3) 调用 old_name( 但排除 obj.old_name(
                    pattern_call = rf"(?<!\.)\b{re.escape(old_name)}\s*\("
                    src_code = re.sub(pattern_call, f"{new_name}(", src_code)
                    return src_code

            code = _rename_function_in_code(code, function_name, new_function_name)
            final_function_name = new_function_name
        else:
            final_function_name = function_name or base_name

        # 写入文件（UTF-8）
        with open(filepath, "w", encoding="utf-8") as f:
            f.write("# -*- coding: utf-8 -*-\n")
            f.write("# Generated by MaiAgent after successful task execution\n\n")
            f.write(code)

        self.logger.info(f" 学到的动作代码已保存: {filepath}")

        # 生成函数描述
        detail_field = "函数描述"
        try:
            prompt = prompt_manager.generate_prompt("learn_action", code=code)
            description_text = await self.llm_client.simple_chat(prompt)
            if description_text:
                detail_field = description_text
                            
        except Exception:
            self.logger.warning(" 生成函数描述失败，将写入占位描述", exc_info=True)

        # 记录到 all_learnt_actions.json
        try:
            record_dir = save_dir
            os.makedirs(record_dir, exist_ok=True)
            record_path = os.path.join(record_dir, "all_learnt_actions.json")

            name_field = f"{filename}/{final_function_name}"

            record_item = {"name": name_field, "detail": detail_field}

            existing: list = []
            if os.path.exists(record_path):
                try:
                    with open(record_path, "r", encoding="utf-8") as rf:
                        existing = json.load(rf)
                        if not isinstance(existing, list):
                            existing = []
                except Exception:
                    existing = []

            # 若已存在相同 name，则更新 detail；否则追加
            updated = False
            for item in existing:
                if isinstance(item, dict) and item.get("name") == name_field:
                    item["detail"] = detail_field
                    updated = True
                    break
            if not updated:
                existing.append(record_item)

            with open(record_path, "w", encoding="utf-8") as wf:
                json.dump(existing, wf, ensure_ascii=False, indent=2)

            self.logger.info(f" 学到的动作记录已更新: {record_path}")
        except Exception:
            self.logger.error(" 更新学到的动作记录失败", exc_info=True)
            
            
action_learner = ActionLearner()